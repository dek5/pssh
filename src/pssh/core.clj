(ns ^{:doc "Выполняет произвольную команду bash параллельно на всех указанных терминалах."}
  pssh.core
  (:use [clojure.string :only [replace-first split upper-case trim-newline join]]
        [clojure.java.shell :only [sh]]
        [clojure.java.io :only [reader]]
        [clojure.tools.cli :only [cli]]
        [clansi.core :only [style]])
  (:gen-class))

(defrecord РезультатВыполнения
	    [терминал		;название терминала
             логин		;имя пользователя, от имени которого выполняется команда
	     вывод-команды	;стандартный вывод (stdout) команды
             вывод-ошибок	;стандартный вывод ошибок (stderr)
             код-завершения])	;код результата выполнения команды


(defmacro безопасно [& выражение]
  "Макрос-обёртка для перехвата исключений"
 `(try ~@выражение
   (catch Exception e# nil)))

(defn- ^РезультатВыполнения выполнить-команду
  "Выполняет заданную команду на заданном терминале. Возвращает РезультатВыполнения."
  [^РезультатВыполнения параметры-команды, команда]
    (let [результат-выполнения-ssh (sh "ssh" "-T" (str (:логин параметры-команды) \@ (:терминал параметры-команды)) команда)]
      (conj параметры-команды {:вывод-команды (:out результат-выполнения-ssh)
    			       :вывод-ошибок (:err результат-выполнения-ssh)
    			       :код-завершения (:exit результат-выполнения-ssh)})))


(defn установить-обработчик-прерывания! ;взято из clojure.repl
  "Регистрирует обработчик сигнала INT. Нажатие Ctrl-C будет вызывать обработчик."
  ([обработчик]
   (sun.misc.Signal/handle
     (sun.misc.Signal. "INT")
     (proxy [sun.misc.SignalHandler] []
       (handle [signal]
         (обработчик))))))

(defn- ^String вывести-с-форматированием
  [^РезультатВыполнения результат]
  "Выводит с форматированием данный результат выполнения команды."
    (let [{:keys [вывод-ошибок вывод-команды код-завершения терминал]} результат
          header (str (style терминал :green) "\n")]
      (str header
        (cond
          (nil? код-завершения) (style "Не отвечает!\n" :red)				;код завершения не определён, значит ssh не отработал
          (not (zero? код-завершения)) (style (str "Ошибка: " вывод-ошибок "\n") :red)) ;код завершния ненулевой, значит ssh отработал, но с ошибкой, поэтому выводим stderr
        (when-not (nil? вывод-команды) вывод-команды))))				;печатает результат выполнения команды

(defn вывести-все [результаты]
  (join (map #(вывести-с-форматированием %) результаты)))

(defn выполнить-команды
  "Выполняет команду на каждом терминале (параллельно с помощью агентов)"
  [команда префикс терминалы логин & [таймаут _]]
    (let [агенты (doall (map #(agent (map->РезультатВыполнения {:терминал (str префикс %), :логин логин})) терминалы))
          завершить-работу-агентов (fn []
                                      (shutdown-agents)
                                      (doall (map #(deref %) агенты))) ]
      (do
        (doseq [x агенты] (send-off x выполнить-команду команда))
        ;Если выполнение ssh на терминале зависло, в случае снятия процесса вывести результаты с остальных терминалов
        (установить-обработчик-прерывания! (comp (fn [& _] (System/exit 1)) (partial println "\nПрервано!\n") вывести-все завершить-работу-агентов))
        (if (integer? таймаут)
          (apply await-for таймаут агенты)
          (apply await агенты))
        (завершить-работу-агентов))))

(defn- прочитать-файл [имя-файла]
  "Считывает содержимое файла"
  (with-open [источник (reader имя-файла)] (doall (line-seq источник))))

(defn- разобрать-список-терминалов [список]
  "Разбирает и принимает список терминалов"
  (if-let [терминалы (безопасно(прочитать-файл список))] терминалы (split список #",")))

(defn- разобрать-командную-строку
  [аргументы]
    (cli аргументы
      ["-h" "--help" "помощь" :default false :flag true]
      ["-s" "--servers" "список терминалов(через запятую) либо имя файла со списком" :parse-fn разобрать-список-терминалов]
      ["-t" "--timeout" "таймаут(сек)" :parse-fn #(* 1000 (Integer. %))]
      ["-p" "--prefix" "префикс номера терминала" :default "appru"]
      ["-l" "--login" "логин для ssh" :default "root"]))

(defn- подсказать-и-выйти [что]
    (do
      (print (replace-first что "Usage:" "Запуск: [switches] команда"))
      (newline)
      (flush)
      (System/exit 1)))

(defn -main [& args]
  (when-let [[{:keys [prefix servers help timeout login]} [команда & _] подсказка] (безопасно(разобрать-командную-строку args))]
    (if
      (or help
	  (nil? servers)
	  (nil? команда))
      (подсказать-и-выйти подсказка)
      (do
        (println (вывести-все (выполнить-команды команда prefix servers login timeout)))
        (System/exit 0)))))
